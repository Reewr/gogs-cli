'use strict';
const fs = require('fs');
const os = require('os');
const path = require('path');

const descriptions = {
  host: 'The address to the Gogs webserver',
  port: 'If the port is not the default for the address given ' +
        '(i.e 80 for http and 443 for https), you can use this to define ' +
        'the port',
  token: 'The access token generated by Gogs. Can be generated by going to ' +
         'Gogs -> Your Settings -> Applications -> Generate New Token',
  debug: 'If true, debug messages are logged'
};

let loaded = false;
let config = {
  host : null,
  port : null,
  token: null,
  debug: false
};

const allowedOptions = Object.keys(config);

/**
 * Tries to retrieve the configuration file path from the environment
 * variables. If it cannot be found, it defaults to
 * ~/.config/gogs-cli/config.json
 *
 * @private
 * @returns {String}
 */
const getConfigPath = function() {
  if (process.env.GOGS_CLI_CONFIG_PATH) {
    return process.env.GOGS_CLI_CONFIG_PATH;
  }

  const homedir = os.homedir();
  const configJoin = ['.config', 'gogs-cli', 'config.json'];

  return path.join(homedir, ...configJoin);
};

/**
 * Checks if the configuration path points to a config file
 *
 * @private
 * @returns {Boolean}
 */
const hasConfigFile = function() {
  return fs.existsSync(getConfigPath());
};

/**
 * Saves the configuration file to the configuration path found by
 * getConfigPath. If the folders don't exist, these are created.
 *
 * @private
 */
const saveConfig = function() {
  const targetPath = getConfigPath();
  const targetDir = path.dirname(targetPath);
  targetDir.split(path.sep).reduce((parentDir, childDir) => {
    const currentDir = path.resolve(parentDir, childDir);

    try {
      fs.mkdirSync(currentDir);
    } catch (err) {
      if (err.code !== 'EEXIST')
        throw err;
    }

    return currentDir;
  }, path.sep);

  fs.writeFileSync(getConfigPath(), JSON.stringify(config));
};

/**
 * Tries to load the configuration file from the configuration file or
 * from the environment variables.
 *
 * Returns the loaded config. Also sets the config in the global scope
 * within this module.
 *
 * @private
 * @returns {Object}
 */
const loadConfig = function() {
  if (process.env.GOGS_CLI_TOKEN && process.env.GOGS_CLI_HOST) {
    config.token = process.env.GOGS_CLI_TOKEN;
    config.host  = process.env.GOGS_CLI_HOST;
    config.port  = process.env.GOGS_CLI_PORT || null;
    config.debug = process.env.GOGS_CLI_DEBUG || false;
  } else {
    const configPath = getConfigPath();

    try {
      config = JSON.parse(fs.readFileSync(configPath).toString());
    } catch (err) {
      if (err.code !== 'ENOENT') {
        console.error(`Failed to load config "${configPath}"`, err);
        return process.exit(1);
      }
    }
  }

  loaded = true;
  config.port = config.port || null;
  config.debug = config.debug || false;

  return config;
};

module.exports = {
  allowedOptions,
  descriptions,

  /**
   * Tries to load the config. If the loaded config does not have a
   * token or a host field, an error is thrown to indicate that these
   * has to be specified.
   *
   * @returns {null}
   */
  exitIfNoTokenOrHost() {
    if (!loaded)
      loadConfig();

    if (!config.token) {
      console.error('ERR: Missing token in config file or environment variables');
      return process.exit(1);
    }

    if (!config.host) {
      console.error('ERR: Missing host in config file or environment variables');
      return process.exit(1);
    }
  }
};

allowedOptions.forEach(x => {
  Object.defineProperty(module.exports, x, {
    get() {
      if (!loaded)
        loadConfig();
      return config[x];
    },
    set(arg) {
      if (!loaded && !hasConfigFile())
        saveConfig();
      else
        loadConfig();

      config[x] = arg;
      saveConfig();
    }
  });
});
